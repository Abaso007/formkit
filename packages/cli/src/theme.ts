import { existsSync } from 'fs'
import http from 'http'
import { writeFile, readFile } from 'fs/promises'
import { resolve } from 'pathe'
import { error, green, __dirname, info } from './index'
import { Theme, ThemeOptions } from '@formkit/theme-creator'
import { stylesheetFromTailwind } from '@formkit/theme-creator/stylesheet'
import { slugify } from '@formkit/utils'
import prompts from 'prompts'
import { createHash } from 'crypto'
import ora from 'ora'
import open from 'open'
import { parse as parseUrl } from 'url'

interface BuildThemeOptions {
  semantic: boolean
  theme?: string
  variables?: string
  api?: string
  format?: 'ts' | 'mjs'
  outFile?: string
}

const DEFAULT_THEME_API = 'https://themes.formkit.com/api'
const DEFAULT_THEME_EDITOR = 'https://themes.formkit.com'
const HAS_EXTENSION_RE = /\.(?:ts|js|mjs|cjs)$/

export async function buildTheme(options: Partial<BuildThemeOptions> = {}) {
  let themeName = options.theme
  if (!options.theme) {
    const generatedTheme = await localGeneratedTheme()
    if (generatedTheme) {
      const [code, path] = generatedTheme
      try {
        const [checksum, variables, theme] = extractThemeData(code)
        const { editMode } = await prompts({
          type: 'confirm',
          message: `Found local theme file for ${theme}, edit this theme?`,
          name: 'editMode',
        })
        if (editMode) {
          return await editTheme(path, code, checksum, variables, theme)
        }
      } catch (err) {
        console.error(err)
        console.info(
          `Detected local theme file but could not parse it. Perhaps it was edited or not generated by FormKit?`
        )
      }
    }
    const res = await fetch(`${DEFAULT_THEME_API}/themes`)
    const themes = await res.json()
    const { theme } = await prompts({
      type: 'select',
      message: 'Select a theme',
      name: 'theme',
      choices: themes.map((theme: any) => ({
        title: theme.name,
        value: theme.slug,
        description:
          theme.description +
          (theme.darkMode ? ' üåú' : '') +
          (theme.lightMode ? '‚òÄÔ∏è' : '') +
          ')',
      })),
    })
    themeName = theme
  }
  if (!themeName) error('Please provide a theme name or path to a theme file.')
  green(`Locating ${themeName}...`)
  const endpoint = options.api || DEFAULT_THEME_API

  const format = options.format || guessFormat()
  const theme = themeName?.startsWith('./')
    ? await generate(
        await localTheme(themeName),
        options.variables,
        format === 'ts',
        options.semantic
      )
    : await apiTheme(
        themeName,
        endpoint,
        options.variables ?? '',
        format === 'ts',
        options.semantic ?? false
      )

  const outFile =
    options.outFile || 'formkit.theme.' + (options.semantic ? 'css' : format)
  await writeFile(resolve(process.cwd(), outFile), theme)
  green(`Theme file written to ${outFile}`)
}

async function editTheme(
  path: string,
  code: string,
  checksum: string,
  variables: string,
  theme: string
) {
  const codeWithoutChecksum = code.replace(
    `* @checksum - ${checksum}`,
    '* @checksum -'
  )
  const newChecksum = createHash('sha256')
    .update(codeWithoutChecksum)
    .digest('hex')
  if (newChecksum !== checksum) {
    const { confirm } = await prompts({
      type: 'confirm',
      message:
        'It appears you‚Äôve edited your theme file. By continuing any changes made to your theme file will be lost. Are you sure you want to continue?',
      name: 'confirm',
      initial: false,
    })

    if (!confirm) {
      return error('Aborting.')
    }
  }
  const [newTheme, newVariables] = await editMode(theme, variables)
  const themeCode = await apiTheme(
    newTheme,
    DEFAULT_THEME_API,
    newVariables,
    path.endsWith('.ts'),
    false
  )
  await writeFile(path, themeCode)
  green(`Theme successfully updated!`)
}

async function editMode(
  theme: string,
  variables: string
): Promise<[string, string]> {
  const url = `${DEFAULT_THEME_EDITOR}?theme=${theme}&variables=${variables}`
  const spinner = ora(`To edit visit: ${url}`).start()
  await open(url)
  let server: http.Server | undefined
  const themeDetails = await new Promise<[string, string]>((resolve) => {
    server = http
      .createServer((req, res) => {
        const urlObj = parseUrl(req.url!, true)
        const theme = urlObj.query.theme as string | undefined
        const variables = urlObj.query.variables as string | undefined
        if (theme && typeof variables !== 'undefined') {
          res.writeHead(200, { 'Content-Type': 'application/json' })
          res.end('{ "status": "complete" }')
          resolve([theme, variables])
        } else {
          res.writeHead(200, { 'Content-Type': 'application/json' })
          res.end('{ "status": "listening" }')
        }
      })
      .listen(5479)
  })
  server?.close()
  spinner.stop()
  return themeDetails
}

function guessFormat() {
  return existsSync(resolve(process.cwd(), 'tsconfig.json')) ? 'ts' : 'mjs'
}

export async function generate(
  theme: Theme<ThemeOptions>,
  variables?: string,
  isTS?: boolean,
  semantic?: boolean
): Promise<string> {
  info(`Loaded theme: ${theme.meta.name}`)
  const vars = parseVariables(variables)
  const classes = theme(vars).tailwind()
  if (semantic) return await stylesheetFromTailwind(classes)
  const classList: Record<string, Record<string, true>> = {}
  const globals: Record<string, Record<string, true>> = {}

  for (const input in classes) {
    for (const section in classes[input]) {
      const key = `${input}__${section}`
      const sectionClasses = classes[input][section]
        .split(' ')
        .reduce((acc, cur) => {
          acc[cur] = true
          return acc
        }, {} as Record<string, true>)
      if (input === '__globals') {
        globals[section] = sectionClasses
      } else {
        classList[key] = sectionClasses
      }
    }
  }

  const themeFile = `${
    isTS ? "import type { FormKitNode } from '@formkit/core'\n\n" : ''
  }/**
  * @privateRemarks
  * This file was generated by the FormKit CLI and should not be manually
  * edited unless you‚Äôd like to "eject" from the CLI‚Äôs ability to update it.
  *
  * @checksum -
  * @variables - ${variables}
  * @theme - ${slugify(theme.meta.name)}
  **/

 /**
  * This is the theme function itself, it should be imported and used as the
  * config.rootClasses function. For example:
  *
  * \`\`\`js
  * import { theme } from './formkit.theme'
  * import { defineFormKitConfig } from '@formkit/vue'
  *
  * export default defineFormKitConfig({
  *   config: {
  *     rootClasses: theme
  *   }
  * })
  * \`\`\`
  **/
 export function rootClasses (sectionName${isTS ? ': string' : ''}, node${
    isTS ? ': FormKitNode' : ''
  })${isTS ? ': Record<string, boolean>' : ''} {
   const key = \`\${node.props.type}__\${sectionName}\`
   const familyKey = node.props.family ? \`family:\${node.props.family}__\${sectionName}\` : ''
   const memoKey = \`\${key}__\${familyKey}\`
   if (!(memoKey in classes)) {
     const sectionClasses = classes[key] ?? globals[sectionName] ?? {}
     if (familyKey in classes) {
       classes[memoKey] = { ...classes[familyKey],  ...sectionClasses }
     } else {
       classes[memoKey] = sectionClasses
     }
   }
   return classes[memoKey]
 }

/**
 * These classes have already been merged with globals using tailwind-merge
 * and are ready to be used directly in the theme.
 **/
const classes${
    isTS ? ': Record<string, Record<string, boolean>>' : ''
  } = ${JSON.stringify(classList, null, 2)};

/**
 * Globals are merged prior to generating this file ‚Äî¬†these are included for
 * any other non-matching inputs.
 **/
const globals${
    isTS ? ': Record<string, Record<string, boolean>>' : ''
  } = ${JSON.stringify(globals, null, 2)};
`

  const checksum = createHash('sha256').update(themeFile).digest('hex')
  return themeFile.replace(/@checksum -/, `@checksum - ${checksum}`)
}

function parseVariables(variables?: string): Record<string, string> {
  if (!variables) return {}
  return variables.split(',').reduce((vars, unparsed) => {
    const [key, value] = unparsed.split('=')
    vars[key] = value
    return vars
  }, {} as Record<string, string>)
}

function getPath(paths: string[]): string | undefined {
  const path = paths.shift()
  if (existsSync(path!)) return path
  return paths.length ? getPath(paths) : undefined
}

async function localGeneratedTheme(): Promise<[string, string] | undefined> {
  const extensions = ['.ts', '.js', '.mjs', '.cjs']
  const paths = extensions.map((ext) =>
    resolve(process.cwd(), 'formkit.theme' + ext)
  )
  const path = getPath(paths)
  if (path) {
    const code = await readFile(path, 'utf-8')
    return [code, path]
  }
  return undefined
}

async function localTheme(
  themeName: string
): Promise<Theme<ThemeOptions>> | never {
  const extensions = ['.ts', '.js', '.mjs', '.cjs']
  const paths = HAS_EXTENSION_RE.test(themeName)
    ? [resolve(process.cwd(), themeName)]
    : extensions.map((ext) => resolve(process.cwd(), themeName + ext))
  const path = getPath(paths)
  if (!path) error(`Could not find ${themeName}.`)

  const theme = (await import(path)) as { default: Theme<ThemeOptions> }
  if (typeof theme !== 'object' || !theme.default) error('Invalid theme file.')
  return theme.default
}

export function extractThemeData(
  theme: string
): [string, string, string] | never {
  const checksumStart = theme.indexOf('@checksum -')
  const variablesStart = theme.indexOf('@variables -')
  const themeStart = theme.indexOf('@theme -')
  if (checksumStart === -1 || variablesStart === -1 || themeStart === -1) {
    throw new Error('Unable to find checksum in theme file.')
  }
  const checksum = theme.substring(
    checksumStart + 12,
    theme.indexOf('\n', checksumStart)
  ) as string
  const variables = theme.substring(
    variablesStart + 13,
    theme.indexOf('\n', variablesStart)
  ) as string
  const themeName = theme.substring(
    themeStart + 9,
    theme.indexOf('\n', themeStart)
  ) as string
  return [checksum, variables, themeName]
}

async function apiTheme(
  themeName: string,
  endpoint: string,
  variables: string,
  isTS: boolean,
  semantic: boolean
): Promise<string> {
  info(`Generating theme: ${themeName}`)
  const res = await fetch(`${endpoint}/generate`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
      theme: themeName,
      variables,
      ts: String(isTS),
      semantic: String(semantic),
    }),
  })
  if (res.ok) {
    const code = await res.text()
    return code
  } else {
    error(`Could not generate theme ‚Äî ${res.statusText}`)
  }
}
